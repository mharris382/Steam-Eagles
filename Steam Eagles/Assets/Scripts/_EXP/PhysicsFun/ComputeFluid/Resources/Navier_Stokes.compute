// This file contains the Navier Stokes equation. The Navier Stokes equation are of the form:
// new_Divergent_vector_field = advection + diffusion + external_forces
// The diffusion is only a linear equation system which is solved by calling the solver several times
// hence this file only contains implemmentation for adding external forces and advection
// plus projection


//____________________________________________________________________________________
// KERNELS

#pragma kernel advection
#pragma kernel divergence
#pragma kernel calculate_divergence_free
#pragma kernel advection_texture
#pragma kernel divergence_texture
#pragma kernel calculate_divergence_free_texture

//____________________________________________________________________________________
// COMMON DECLERNATIONS

#include "FluidDynamicCommonUniforms.cginc"


//____________________________________________________________________________________
// HELPER FUNCTIONS

#include "FluidDynamicUtility.cginc"


float4 TextureBilinearLoad(Texture2D<float4> texture, float2 coordinate) 
{
    float4 closest_grid_coords;

    closest_grid_coords.xy = max(0.,round(coordinate - 0.5));                // Get the left and lower closest grid centers
    closest_grid_coords.zw = closest_grid_coords.xy + float2(1., 1.);   // Right, upper closest grid centers

    float2 lerp_factors    = coordinate - closest_grid_coords.xy;
    // Get the fractional part of the actual sample position to the closest left-down sided grid center
    

    float4 left_down  = texture[closest_grid_coords.xy];
    float4 right_down = texture[closest_grid_coords.zy];
    float4 left_up    = texture[closest_grid_coords.xw];
    float4 right_up   = texture[closest_grid_coords.zw];


    return lerp(lerp(left_down, right_down, lerp_factors.x),             // Bilinear interpolation in x direction on the lower part
                lerp(left_up,   right_up,   lerp_factors.x),             // Bilinear interpolation in x direction on the upper part
                lerp_factors.y);                                         // Same but in y direction
}
float4 TextureBufferBilinearLoad(Texture2D<float4> buffer, float2 coord) 
{
    float4 closest_grid_coords;

    closest_grid_coords.xy = max(0.,round(coord - 0.5));                // Get the left and lower closest grid centers
    closest_grid_coords.zw = closest_grid_coords.xy + float2(1., 1.);   // Right, upper closest grid centers

    float2 lerp_factors    = coord - closest_grid_coords.xy;            // Get the fractional part of the actual sample position to the closest left-down sided grid center
    

    float4 left_down  = buffer[closest_grid_coords.xy];
    float4 right_down = buffer[closest_grid_coords.zy];
    float4 left_up    = buffer[closest_grid_coords.xw];
    float4 right_up   = buffer[closest_grid_coords.zw];


    return lerp(lerp(left_down, right_down, lerp_factors.x),             // Bilinear interpolation in x direction on the lower part
                lerp(left_up,   right_up,   lerp_factors.x),             // Bilinear interpolation in x direction on the upper part
                lerp_factors.y);                                         // Same but in y direction
}
//____________________________________________________________________________________
// MAIN FUNCTIONS

// ADVECTION DECLERNATIONS

float                      _dissipationFactor;                              // This factor determines how fast the quantities dissapate over time. 
uint2 _tex_size;
float2 _grid_scale;
Texture2D<float4>   _velocity_field_buffer;                          // The velocity field which does the carrying
Texture2D<float4>   _field_to_advect_buffer;                         // this is the field which is being carried off by the vector field, it can be temperature, dye, or the velocity itself
RWTexture2D<float4> _new_advected_field;
//----------------------------------------------------------------------------
// Function         : Advection
// Description      : Advection is the part of the equation that is responsible for carrying
//                    things along the fluid field. This can be head, densities or even the 
//                    the velocity of the fluid itself. It works by tracing backwards in time
//                    and seeing what qunatities the current velocity would have brought to the 
//                    cell which is being examined.
//                    It performs bilinear interpolation at the destination to get a smooth
//                    resulting field. It also clamps the velocities on the bounderies.

//----------------------------------------------------------------------------

[numthreads(16,16,1)]                                                        // Runs once per simulation grid
void advection(uint3 id : SV_DispatchThreadID)                              
{
    const uint2 coord = id.xy;                                                   // One to one mapping between the dispatch ids and the coordinate
    float2 advection_source_coord = coord -(i_timeStep * _velocity_field_buffer[coord]);
    advection_source_coord/= _grid_scale;
    advection_source_coord = clamp(advection_source_coord, 0, _tex_size - 1);
    _new_advected_field[coord] = _dissipationFactor * TextureBufferBilinearLoad(_field_to_advect_buffer, advection_source_coord);
}



float                      _dissipationFactor_texture;                              // This factor determines how fast the quantities dissapate over time. 

Texture2D<float4>   _velocity_field_buffer_texture;                          // The velocity field which does the carrying
Texture2D<float4>   _field_to_advect_buffer_texture;                         // this is the field which is being carried off by the vector field, it can be temperature, dye, or the velocity itself

RWStructuredBuffer<float4> _new_advected_field_texture;                             // The results of advection is written on this field

[numthreads(16,16,1)]                                                        // Runs once per simulation grid
void advection_texture(uint3 id : SV_DispatchThreadID)
{
    float2  coord = id.xy;                                                   // One to one mapping between the dispatch ids and the coordinate
    
    float2 advection_source_coord = coord -                                  // Trace backwards along trajectory
                                  (i_timeStep *                              // distance = velocity * time, this is the time part 
                                  _velocity_field_buffer_texture[coord] *               // This is the velocity part
                                  (1. / i_grid_scale)) ;                     // The speed is in the unite of grids, but since the grid might not be unit-scale, we need to also scale by the grid cell size.
    
    
    advection_source_coord = clamp(advection_source_coord,                   // Handling the case where the velocity traces back to outside the bounds of the buffer
                                   0.0, i_Resolution - 1.0);                 // left hand side ensures the smallest element to read is element , and the biggest n-1
    
    _new_advected_field_texture[coord] = _dissipationFactor *              // Disspation factor 1 = lasts forever, 0 = instantly dissipates, dunno how physcilly accurate this is. 
                            TextureBilinearLoad(_field_to_advect_buffer_texture, advection_source_coord);
}
// _______________________________

// DIVERGENCE DECLERNATIONS

StructuredBuffer<float4>     _divergence_vector_field;                      // This is the vector field which we want to calculate the divergence of, the members of the array are quanteties in this vector field
RWStructuredBuffer<float4>   _divergence_values;                            // The results are written to this buffer


//----------------------------------------------------------------------------
// Function         : divergence
// Description      : Divergence is a physical measure of how much stuff flow in 
//                    or out of a point in a vector field. Since fluids can not be 
//                    compressed, the fluid field needs to have a divergence of 0 everywhere.
//                    The quanteties we calculate are at first not divergence free, however by
//                    calculating its divergence and using a possion equation we can split up the 
//                    the vector field in a divergence and curl components, and keep the curl one.
//                    For a more none math explaination, look at my blog post Gentle Introduction to Fluid Simulation for Programmers and Techincal Artists
//                    Divergence = partial(field.x)/ partial(x) + partial(field.y)/partial(y)
//                    The partial(x) = partial(y) = 1.0/(2.0*cellSize)
//----------------------------------------------------------------------------

[numthreads(16, 16, 1)]                                                     // runs once per cell of the vector field
void divergence(uint3 id : SV_DispatchThreadID)
{                                                                           
    float partialXY = 2. * i_grid_scale;
    int2  coord     = id.xy;                                                // one to one mapping between thread ids in the dispatch and the structured buffer

    float4 left     = _divergence_vector_field[id2Dto1D(coord - int2(1, 0))];
    float4 right    = _divergence_vector_field[id2Dto1D(coord + int2(1, 0))];
    float4 bottom   = _divergence_vector_field[id2Dto1D(coord - int2(0, 1))];
    float4 top      = _divergence_vector_field[id2Dto1D(coord + int2(0, 1))];

    _divergence_values[id2Dto1D(coord)] = 
                       ((right.x - left.x + top.y - bottom.y) *  1. / partialXY).xxxx;
}


// DIVERGENCE DECLERNATIONS

Texture2D<float4>     _divergence_vector_field_texture;                      // This is the vector field which we want to calculate the divergence of, the members of the array are quanteties in this vector field
RWTexture2D<float4>   _divergence_values_texture;                            // The results are written to this buffer


[numthreads(16, 16, 1)]                                                     // runs once per cell of the vector field
void divergence_texture(uint3 id : SV_DispatchThreadID)
{                                                                           
    float partialXY = 2. * i_grid_scale;
    int2  coord     = id.xy;                                                // one to one mapping between thread ids in the dispatch and the structured buffer

    float4 left     = _divergence_vector_field_texture[coord - int2(1, 0)];
    float4 right    = _divergence_vector_field_texture[coord + int2(1, 0)];
    float4 bottom   = _divergence_vector_field_texture[coord - int2(0, 1)];
    float4 top      = _divergence_vector_field_texture[coord + int2(0, 1)];

    _divergence_values_texture[coord] = 
                       ((right.x - left.x + top.y - bottom.y) *  1. / partialXY).xxxx;
}

    
// _______________________________

// CALCULATE_DIVERGENCE_FREE DECLERNATIONS

StructuredBuffer<float4>    _non_zero_divergence_velocity_field;            // This is the velocity field which we have calculated after advection, diffusion and adding external forces
StructuredBuffer<float4>    _pressure_field;                                // This is actually a scalar float field.But to be able to use a generic solver for the possion equation as well as diffusion I am using a float4 structured buffer. The pressure field is calculated with the solve from the euqation lepralce(pressure_field) = divergence(velocity_field) 
RWStructuredBuffer<float4>  _pressure_gradient;                             // It is not nesscerly to save this on device memory, it could also be saved in the thread register and immedietly subtracted from the non zero divergent vector field, however for debug porpuses, I write this to the vram
RWStructuredBuffer<float4>  _divergence_free_field;                         // the result of the projection is written here

//----------------------------------------------------------------------------
// Function         : calculate_divergence_free
// Description      : Last step of the navier stoke equations. After the pressure disturbance 
//                    caused by the non zero diveragnce vector field is calculated through the possion equation, 
//                    the acceleration caused by this uneven pressure field is calculated by taking the gradient of this
//                    pressure field and subtracted from the non zero divergence vector field. 
//                    
//                    divergence_free_vector_field = non_zero_divergence_vector_field - gradient(pressure_field)
//----------------------------------------------------------------------------
[numthreads(16, 16, 1)]                                                     // runs once per cell of the vector field
void calculate_divergence_free(uint3 id : SV_DispatchThreadID)
{                                                                           
     float partialXY = 2. * i_grid_scale;
     int2 coord      = id.xy;                                               // one to one mapping between thread ids in the dispatch and the structured buffer

     float4 gradient_value = gradient(_pressure_field, partialXY, coord);

     _pressure_gradient[id2Dto1D(coord)] = gradient_value;                  // For debug and visualisation porpuses

     _divergence_free_field[id2Dto1D(coord)] = 
            _non_zero_divergence_velocity_field[id2Dto1D(coord)] - gradient_value;

}


Texture2D<float4> _non_zero_divergence_velocity_field_texture;              // This is the velocity field which we have calculated after advection, diffusion and adding external forces
Texture2D<float4> _pressure_field_texture;                                  // This is actually a scalar float field.But to be able to use a generic solver for the possion equation as well as diffusion I am using a float4 structured buffer. The pressure field is calculated with the solve from the euqation lepralce(pressure_field) = divergence(velocity_field)
RWTexture2D<float4> _pressure_gradient_texture;                             // It is not nesscerly to save this on device memory, it could also be saved in the thread register and immedietly subtracted from the non zero divergent vector field, however for debug porpuses, I write this to the vram
RWTexture2D<float4> _divergence_free_field_texture;                         // the result of the projection is written here

//----------------------------------------------------------------------------
// Function         : calculate_divergence_free
// Description      : Last step of the navier stoke equations. After the pressure disturbance
//                    caused by the non zero diveragnce vector field is calculated through the possion equation,
//                    the acceleration caused by this uneven pressure field is calculated by taking the gradient of this
//                    pressure field and subtracted from the non zero divergence vector field.
//
//                    divergence_free_vector_field = non_zero_divergence_vector_field - gradient(pressure_field)
//----------------------------------------------------------------------------
[numthreads(16, 16, 1)]                                                     // runs once per cell of the vector field
void calculate_divergence_free_texture(uint3 id : SV_DispatchThreadID)
{
    float partialXY = 2. * i_grid_scale;
    int2 coord = id.xy;                                               // one to one mapping between thread ids in the dispatch and the structured buffer

    float4 gradient_value = gradient_texture(_pressure_field_texture, partialXY, coord);

    _pressure_gradient_texture[id.xy] = gradient_value;                  // For debug and visualisation porpuses

    _divergence_free_field_texture[id.xy] =
        _non_zero_divergence_velocity_field_texture[id.xy] - gradient_value;

}