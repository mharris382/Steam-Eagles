// Each #kernel tells which function to compile; you can have many kernels
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DynamicGasIO
#pragma kernel DeleteGasOnBoundaries
#pragma kernel DynamicExternalForcesInput
struct IO
{
    int2 texCoord;
    int2 size;
    float valueToAdd;
    float valueAdded;
};

const uint a = 1664525u;
const uint c = 1013904223u;
const uint m = 4294967296u;
uint random_seed(uint2 texCoord)
{
    uint seed = texCoord.x + texCoord.y;
    seed = (a * seed + c) % m;
    return seed;
}
float random(uint seed)
{
    seed = (a * seed + c) % m;
    return seed / (float)m;
}
int ioCount;
float maxPressure  = 1;

RWStructuredBuffer<IO> ioBuffer;
RWTexture2D<float4> gas;
RWTexture2D<float4> gasVelocity;

float AddToCell(uint2 cell, float delta)
{
    float gasCurrent = gas[cell].x;
    float gasNew = clamp(gasCurrent + delta, 0, maxPressure);
    gas[cell] = float4(gasNew,  gasNew,  gasNew, gasNew);
    gasVelocity[cell] = float4(random(cell.x), random(cell.y), 0, 1);
    return gasNew - gasCurrent;
}
[numthreads(8,1,1)]
void DynamicGasIO (uint3 id : SV_DispatchThreadID)
{
    IO io = ioBuffer[id.x];
    
    for (int x =  0; x < io.size.x; x++)
    {
        for (int y = 0; y < io.size.y; y++)
        {
            if(io.valueToAdd == 0)return;
            int2 texCoord = int2(io.texCoord.x + x, io.texCoord.y + y);
            float gasDelta = AddToCell(texCoord, io.valueToAdd);
            io.valueAdded += gasDelta;
            io.valueToAdd -= gasDelta;
            ioBuffer[id.x] = io;
            // int2 upCoord = int2(texCoord.x, texCoord.y + 1);
            // int2 downCoord = int2(texCoord.x, texCoord.y - 1);
            // int2 leftCoord = int2(texCoord.x - 1, texCoord.y);
            // int2 rightCoord = int2(texCoord.x + 1, texCoord.y);
            //
            //
            //
            // float gasUp = gas[upCoord].x;
            // float gasDown = gas[downCoord].x;
            // float gasLeft = gas[leftCoord].x;
            // float gasRight = gas[rightCoord].x;
            //
            // //gas[texCoord] = float4(gasClamped,  gas[texCoord].y,  gas[texCoord].z, gas[texCoord].w);
            // io.valueAdded += gasDelta;
        }
    }
    // float gasCurrent = gas[io.texCoord].x;
    // float gasNew = gasCurrent + io.valueToAdd;
    // float gasClamped = clamp(gasNew, 0, 1);
    // float gasDelta = gasClamped - gasCurrent;
    // gas[io.texCoord] = float4(gasClamped,  gas[io.texCoord].y,  gas[io.texCoord].z, gas[io.texCoord].w);
    // io.valueAdded = gasDelta;
    ioBuffer[id.x] = io;
}

uint2 boundaryScale = uint2(1,1);
Texture2D<float> boundary;
RWTexture2D<float4> gasState;


uint2 BoundaryToGasTextureCoord(uint2 boundaryCoord)
{
    return boundaryCoord * boundaryScale;
}
uint2 GasToBoundaryTextureCoord(uint2 gasCoord)
{
    return gasCoord / boundaryScale;
}



[numthreads(8,8,1)]
void DeleteGasOnBoundaries(uint3 id : SV_DispatchThreadID)
{
    uint2 boundaryTexCoord = id.xy;
    float boundaryValue = boundary[boundaryTexCoord];
    if(boundaryValue == 0)
        return;
    uint2 gasTexCoord = BoundaryToGasTextureCoord(boundaryTexCoord);
    for (int x = 0; x < boundaryScale.x; x ++)
    {
        for (int y = 0; y < boundaryScale.y; y ++)
        {
            float4 prevGasState = gasState[gasTexCoord + uint2(x,y)];
            gasState[gasTexCoord + uint2(x,y)] = float4(0,prevGasState.g,prevGasState.z,prevGasState.w);
        }   
    }
}
struct ForceInput
{
    int2 texCoord;
    int2 area;
    float2 forceToAdd;
};

StructuredBuffer<ForceInput> forceInputBuffer;
RWTexture2D<float2> velocityTextureInputTarget;

[numthreads(8,2,1)]
void DynamicExternalForcesInput(uint3 id : SV_DispatchThreadID)
{
    ForceInput input = forceInputBuffer[id.x]; 
    for (int x = id.y %  2; x < boundaryScale.x; x +=2)
    {
        for (int y = id.y %  2; y < boundaryScale.y; y +=2)
        {
            int2 texCoord = input.texCoord + int2(x,y);
            float2 velocity = velocityTextureInputTarget[texCoord];
            velocity += input.forceToAdd;
            velocityTextureInputTarget[texCoord] = velocity;
        }
    }
}


struct HeatInput
{
    int2 texCoord;
    int2 area;
    float heatToAdd;
};

StructuredBuffer<HeatInput> heatInputBuffer;
RWTexture2D<float4> heatTexture;

[numthreads(8,1,1)]
void DynamicHeatInput(uint3 id : SV_DispatchThreadID)
{
    HeatInput input = heatInputBuffer[id.x]; 
    for (int x = id.y %  2; x < boundaryScale.x; x +=2)
    {
        for (int y = id.y %  2; y < boundaryScale.y; y +=2)
        {
            int2 texCoord = input.texCoord + int2(x,y);
            float heat = heatTexture[texCoord].z;
        }
    }
}

RWTexture2D<float4> velocityTexture;
Texture2D<float4> gasStateTexture;
[numthreads(8,8,1)]
void Project(uint3 id : SV_DispatchThreadID)
{
    uint2 texCoord = id.xy;
    float4 gasState = gasStateTexture[texCoord];
    float4 velocity = velocityTexture[texCoord];
    float2 velocity2D = velocity.xy;
    float2 velocity2DProjected = velocity2D - gasState.xy * velocity2D;
    velocityTexture[texCoord] = float4(velocity2DProjected, velocity.z, velocity.w);
}


void Diffuse(uint2 texCoord, float4 gasState, float4 velocity)
{
    float2 velocity2D = velocity.xy;
    float2 velocity2DProjected = velocity2D - gasState.xy * velocity2D;
    velocityTexture[texCoord] = float4(velocity2DProjected, velocity.z, velocity.w);
}
// void ProjectVelocity(uint2 texCoord)
// {
//     float4 gasState = gasStateTexture[texCoord];
//     float4 velocity = velocityTexture[texCoord];
//     float2 velocity2D = velocity.xy;
//     float2 velocity2DProjected = velocity2D - gasState.xy * velocity2D;
//     velocity[texCoord] = float4(velocity2DProjected, velocity.z, velocity.w);
// }